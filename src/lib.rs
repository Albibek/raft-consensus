//! # Raft
//!
//! This is a crate containing a Raft consensus implementation and protocol message encoding/decoding
//! helpers.
//!
//! Main features:
//! * Snapshotting(TODO)
//! * Sticky leader. Partial network partitioning does not make leader to flap.
//! * Leader step down(TODO). Given a special command, leader may give up it's leadership to
//! another node.
//! * Configuration change API. Peer nodes can be added and removed(TODO) dynamically with the changes
//! propagated over the cluster. Removed node becomes non-voting follower(TODO), receiving
//! the trail of messages (eventually ending, because of being removed from cluster)
//! * Panic-free(TODO). Only unrecoverable error can be returned, but no panic happens when
//! messages are processed.
//!
//! This crate only implements a logic part and is not tied to any network implementation. This
//! means that users of it should use the external implementation of the networking layer. The
//! crate though contains useful helpers to serialize/deserialize messages. The mapping of
//! node/client/admin IDs should be done by this external implementation.
//!
//! The usage of the crate assumes usage of the following parts:
//!
//! * Implementations for persistent log and state machine should comply with `persistent_log::Log`
//! and `state_machine::StateMachine` traits
//!
//! * Timeouts are provided using `Raft::apply_timeout` function.
//!
//! * The network part provides incoming messages one by one using the corresponding methods of `Raft` structure
//! together with the implementation of a `Handler` trait, which is used from inside a consensus.
//! It is recommended to carefully read all the documentation for the trait methods to avoid
//! mistakes.
//!
//! ## Message APIs
//! The network implementation is highly recommented to use the API parts separately
//! with corresponding limitations(like different ports or authentication) for each of them.
//!
//! * The `PeerMessage` API. This is a core Raft protocol messages required  to do it's main
//! job, i.e. keeping the leader in sync with the followers and perform leader election when required.
//! * The `ClientMessage` API. This is the API to make modifications to state machine and/or
//! querying it
//! * The `AdminMessage` API. Used for making configuration changes inside the cluster. Mostly
//! the cluster membership changes, but also pings with useful information.
//!
//! ## Error handling
//! The `Error` enum returned from the functions can be critical (can be also checked by is_critial
//! method). If this kind of error is returned, the consensus falls into the special `Lost` state
//! which cannot be transitioned from. In such a case the consensus must be considered
//! inconsistent, because there is no guarantee, that for example data was written to a log or data
//! was correctly read from the log. Obviously, the errors about implementation bugs should also
//! be reported and fixed.
//!
//! Note, that panic-free guarantee is only bounded to consensus implementation. The `Log` and `StateMachine`
//! implementations may have no such guarantee because since they are provided by caller.
//!

/// Raft consensus API
pub mod raft;

/// handler for consensus callbacks
pub mod handler;

/// messages that are passed during consensus work
#[cfg_attr(feature = "use_capnp", macro_use)]
pub mod message;

/// error types
pub mod error;

/// trait for persistent log along with some debug implementations
pub mod persistent_log;

/// trait for state machine along with some debug implementations
pub mod state_machine;

/// consensus configuration
pub mod config;

#[cfg(feature = "use_capnp")]
/// autogenerated capnproto structures
pub mod messages_capnp {
    //    #![allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/schema/messages_capnp.rs"));
}

// Data and functions for all states
mod state;

// Trait and helpers for internal state handling API
mod state_impl;

// Module with all functions required in follower state
mod candidate;
// Module with all functions required in candidate state
mod follower;
// Module with all functions required in leader state
mod leader;

use std::{fmt, ops};

#[cfg(feature = "use_serde")]
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::error::Error;

pub use crate::config::ConsensusConfig;
pub use crate::handler::Handler;
pub use crate::message::admin::ConsensusState;
pub use crate::persistent_log::Log;
pub use crate::raft::{Raft, RaftBuilder};
pub use crate::state_machine::StateMachine;

/// The term of a log entry.
#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "use_serde", derive(Serialize, Deserialize))]
pub struct Term(pub u64);
impl Term {
    pub fn as_u64(self) -> u64 {
        self.0
    }
}

impl From<u64> for Term {
    fn from(val: u64) -> Term {
        Term(val)
    }
}

impl Into<u64> for Term {
    fn into(self) -> u64 {
        self.0
    }
}

impl ops::Add<u64> for Term {
    type Output = Term;
    fn add(self, rhs: u64) -> Term {
        Term(
            self.0
                .checked_add(rhs)
                .expect("overflow while incrementing Term"),
        )
    }
}

impl ops::Sub<u64> for Term {
    type Output = Term;
    fn sub(self, rhs: u64) -> Term {
        Term(
            self.0
                .checked_sub(rhs)
                .expect("underflow while decrementing Term"),
        )
    }
}

impl fmt::Display for Term {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}

/// The index of a log entry.
#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "use_serde", derive(Serialize, Deserialize))]
pub struct LogIndex(pub u64);
impl LogIndex {
    pub fn as_u64(self) -> u64 {
        self.0
    }
    pub fn as_usize(self) -> usize {
        self.0 as usize
    }
}

impl From<u64> for LogIndex {
    fn from(val: u64) -> LogIndex {
        LogIndex(val)
    }
}

impl Into<u64> for LogIndex {
    fn into(self) -> u64 {
        self.0
    }
}

impl ops::Add<u64> for LogIndex {
    type Output = LogIndex;
    fn add(self, rhs: u64) -> LogIndex {
        LogIndex(
            self.0
                .checked_add(rhs)
                .expect("overflow while incrementing LogIndex"),
        )
    }
}

impl ops::Sub<u64> for LogIndex {
    type Output = LogIndex;
    fn sub(self, rhs: u64) -> LogIndex {
        LogIndex(
            self.0
                .checked_sub(rhs)
                .expect("underflow while decrementing LogIndex"),
        )
    }
}

/// Find the offset between two log indices.
impl ops::Sub for LogIndex {
    type Output = u64;
    fn sub(self, rhs: LogIndex) -> u64 {
        self.0
            .checked_sub(rhs.0)
            .expect("underflow while subtracting LogIndex")
    }
}

impl fmt::Display for LogIndex {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}

/// peer ID and metadata
#[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd, Debug)]
#[cfg_attr(feature = "use_serde", derive(Serialize, Deserialize))]
pub struct Peer {
    pub id: ServerId,
    pub metadata: Vec<u8>,
}

/// The ID of a Raft peer node. Must be unique among the participants in a
/// consensus group.
#[derive(Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd, Debug)]
#[cfg_attr(feature = "use_serde", derive(Serialize, Deserialize))]
pub struct ServerId(pub u64);

impl ServerId {
    pub fn as_u64(self) -> u64 {
        self.0
    }
}

impl From<u64> for ServerId {
    fn from(val: u64) -> ServerId {
        ServerId(val)
    }
}

impl Into<u64> for ServerId {
    fn into(self) -> u64 {
        self.0
    }
}

impl fmt::Display for ServerId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}

/// The ID of a Raft client.
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug, Default)]
#[cfg_attr(feature = "use_serde", derive(Serialize, Deserialize))]
pub struct ClientId(pub Uuid);
impl ClientId {
    pub fn new() -> ClientId {
        ClientId(Uuid::new_v4())
    }

    pub fn as_bytes(&self) -> &[u8] {
        self.0.as_bytes()
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<ClientId, Error> {
        Uuid::from_slice(bytes).map(ClientId).map_err(Error::Uuid)
    }
}

impl fmt::Display for ClientId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}

/// The ID of a Raft administrator.
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug, Default)]
#[cfg_attr(feature = "use_serde", derive(Serialize, Deserialize))]
pub struct AdminId(pub Uuid);
impl AdminId {
    pub fn new() -> AdminId {
        AdminId(Uuid::new_v4())
    }

    pub fn as_bytes(&self) -> &[u8] {
        self.0.as_bytes()
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<AdminId, Error> {
        Uuid::from_slice(bytes).map(AdminId).map_err(Error::Uuid)
    }
}

impl fmt::Display for AdminId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}
